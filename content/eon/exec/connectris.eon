#include "content/eon/libs/libload.eon"
#include "content/eon/libs/sys.eon"

value createMap() {
    // tileSize, width, height
    value result = "";
    value x;
    value y;

    for (x = 0; x < 8; x = x + 1) {
        result = result & @x;
    }

    value size = 1 * 8 * 23;
    result = result & new size;

    return result;
}

value getTile(value map, value pos) {
    value tile = map + pos;
    value tilev = @tile;

    value id = tilev + 65;

    //print(@id);

    value x = tilev / 4;
    value y = tilev % 4;

    return _MakeRect(256 * x, 256 * y, 256, 256);
}

value renderMap(value map, value win, value tex) {
    value x;
    value y;
    value pos = 0;
    value id = "";
    value source = _MakeRect(256, 0, 256, 256);
    value dest = _MakeRect(0, 0, 16, 16);

    for (y = 0; y < 24; y = y + 1) {
        for (x = 0; x < 8; x = x + 1) {
            pos = y * 8;
            pos = pos + x;
            id = map + pos;

            if (@id) {
                source = getTile(map, pos);
                dest = _MakeRect(x * 16, y * 16, 16, 16);

                _WindowRender(win, tex, dest, source);
            }
        }

        //print("\\n");
    }
    //print("========\\n");

    return 0;
}

value updateMap(value map) {
    value x = 0;
    value y = 1;
    value result = "";
    value pos = 0;
    value posup = 0;
    value posdown = 0;
    value tile = 0;
    value tileup = 0;
    value tiledown = 0;
    value tilev = "";
    value tileupv = "";
    value tiledownv = "";

    for (x = 0; x < 8; x = x + 1) {
        result = result & @0;
    }

    for (y = 0; y < 23; y = y + 1) {
        for (x = 0; x < 8; x = x + 1) {
            posup = y * 8;
            posup = posup + x;

            pos = posup + 8;
            posdown = pos + 8;

            tilev = map + pos;
            tile = @tilev;

            tileupv = map + posup;
            tileup = @tileupv;

            tiledownv = map + posdown;
            tiledown = @tiledownv;
            if (y == 22) {
                tiledown = 15;
            }

            if (tile == 0) {
                if (tileup != 0) {
                    result = result & @tileup;
                } else {
                    result = result & @0;
                }
            } else {
                if (tiledown == 0) {
                    result = result & @0;
                } else {
                    result = result & @tile;
                }
            }
        }
    }

    return result;
}

value update(value map, value cntr, value dt) {
    cntr = cntr + dt;

    if (cntr > 100) {
        cntr = cntr - 100;
        map = updateMap(map);
    }

    return 0;
}

value main() {
    setupLibLoad();
    loadLib("/libs/window.ell");
    loadLib("/libs/texture.ell");
    loadLib("/libs/string.ell");

    value map = createMap();
    value window = _WindowCreate();
    value texture = _TextureCreate();
    value lastTime = time();
    value cntr = 0;
    value dt = 0;

    value test = "";

    _TextureUpload(_TextureRead("/cont/imgs/connectris.eia"), texture);

    for (0; _WindowOpen(); 1) {
        dt = time() - lastTime;
        lastTime = time();

        update(map, cntr, dt);
        
        renderMap(map, window, texture);
        
        _WindowFlip(window);
    }

    _TextureDestroy(texture);
    _WindowDestroy(window);

    asm "ret";
}

