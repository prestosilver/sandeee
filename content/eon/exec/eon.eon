#include "/libs/inc/sys.eon"
#include "/libs/inc/libload.eon"

fn isWhitespace(char) {
    // returns 1 if char is whitespace
    if (@char == 32) return 1; // space
    if (@char == 10) return 1; // lf
    if (@char == 11) return 1; // tab
    if (@char == 13) return 1; // cr

    return 0;
}

fn single(char) {
    // returns 1 if char should be a whole word
    if (@char == 59) return 1;  // ;
    if (@char == 123) return 1; // {
    if (@char == 125) return 1; // }
    if (@char == 40) return 1;  // (
    if (@char == 41) return 1;  // )
    if (@char == 44) return 1;  // ,
    if (@char == 64) return 1;  // @

    return 0;
}

fn setSize() {
    // sets the size of a string
    asm "size";
    asm "ret";
}

fn nextWord(buff, idx) {
    // gets the next word in a buffer

    var copy = dup(buff) + idx;
    var length = 0;
    var done = 0;
    var ws = 0;
    var char = "";
    var word = 1;
    if (isWhitespace(copy)) {
        word = 0;
    }

    if (@copy == 34) {
        length = length + 1;
        idx = idx + 1;
    } else if (single(copy)) {
        idx = idx + 1;
        copy = setSize(copy, 1);

        return copy;
    }

    while (done == 0) {
        char = dup(copy) + length;
        char = setSize(char, 1);
        if (@char == 92) {
            length = length + 2;
            idx = idx + 2;
        } else {
            ws = isWhitespace(char);
            if (@copy == 34) {
                if (@char == 34) {
                    if (length > 0) {
                        done = 1;
                        length = length + 1;
                        idx = idx + 1;
                    }
                }
            } else if (single(char)) {
               if (length == 0) {
                   idx = idx + 1;

                   return char;
               }

               done = 1;
            }

            if (@copy == 34) {
                ws = 0;
            }

            if (done == 0) {
                if (char == "") done = 1;

                if ((ws == 1) && (word == 0)) {
                    idx = idx + 1;
                    copy = copy + 1;
                } else if ((ws == 0) && (word == 0)) {
                    word = 1;
                } else if ((ws == 1) && (word == 1)) {
                    done = 1;
                    word = 0;
                }

                if (word) {
                    length = length + 1;
                    idx = idx + 1;
                }
            }
        }
    }

    copy = setSize(copy, length);
    
    var result = "";
    var ch = "";
    var tmp = "";
    for (0; copy != ""; copy = copy + 1) {
        ch = @copy;
        result = result & @ch;
        if (ch == 92) {
            result = result - 1;
            copy = copy + 1;
            if (@copy == 110) {
                result = result & @92;
                result = result & @110;
            } else if (@copy == 116) {
                result = result & @92;
                result = result & @116;
            } else {
                tmp = @copy;
                result = result & @tmp;
            }
        }
    }


    return result;
}

fn parseVar(buff, idx, stack, varTable) {
    var lastidx = dup(idx);
    var word = nextWord(buff, idx);
    var next = "";
    var oldidx;

    if (word == "var") {
        word = nextWord(buff, idx);

        if (stack != 255) stack = stack + 1;

        while (_StringLength(word) < 20) {
            word = word & @0;
        }

        _TablePut(varTable, word, @stack);

        oldidx = dup(idx);

        next = nextWord(buff, idx);

        if (next == "=") {
           if (stack != 255) stack = stack - 1;

            return parseExpression(buff, idx, stack, varTable);
        }

        idx = dup(oldidx);

        return "    push 0\n";
    }

    idx = dup(lastidx);

    return "";
}

fn toString(number) {
   if (number == 0) {
       return "0";
   }

   var result = "";
   var tmp = "";

   for (0; number > 0; number = number / 10) {
       tmp = @(48 + (number % 10));
       result = tmp & result;
   }

   return result;
}

fn parseFlow(buff, idx, stack, varTable) {
    var lastidx = dup(idx);
    var oldstack = dup(stack);
    var flowidx = toString(lastidx);
    var word = nextWord(buff, idx);
    var result = "";
    var last = "";

    if (word == "if") {
        word = nextWord(buff, idx);
        if (word == "(") {
            result = result & parseExpression(buff, idx, stack, varTable);
            word = nextWord(buff, idx);
            if (word == ")") {
                if (stack != 255) stack = stack - 1;
                result = result & "    jz if_" & flowidx & "_else\n";

                result = result & parseBlock(buff, idx, stack, varTable, 0);

                stack = dup(oldstack);

                result = result & "    jmp if_" & flowidx & "_end\n";
                result = result & "if_" & flowidx & "_else:\n";

                last = dup(idx);

                word = nextWord(buff, idx);
                if (word == "else") {
                    result = result & parseBlock(buff, idx, stack, varTable, 0);

                    stack = dup(oldstack);
                } else {
                    idx = dup(last);
                }

                result = result & "if_" & flowidx & "_end:\n";
                stack = dup(oldstack);

                return result;
            }
        }
    }

    if (word == "while") {
        word = nextWord(buff, idx);

        result = "while_" & flowidx & "_loop:\n";
        if (word != "(") error("for expected '('");

        result = result & parseExpression(buff, idx, stack, varTable);
        result = result & "    jz while_" & flowidx & "_end\n";
        if (stack != 255) stack = stack - 1;

        word = nextWord(buff, idx);
        if (@word != ")") error("for expected ')' got " & word);

        result = result & parseBlock(buff, idx, stack, varTable, 0);

        result = result & "    jmp while_" & flowidx & "_loop\nwhile_" & flowidx & "_end:\n";

        stack = oldstack;

        return result;
    }

    if (word == "for") {
        word = nextWord(buff, idx);
        if (word != "(") error("for expected '('");

        result = parseExpression(buff, idx, stack, varTable);

        word = nextWord(buff, idx);
        if (@word != 59) error("for expected 'sc1' got " & word);

        result = result & "    disc 0\nfor_" & flowidx & "_loop:\n";
        if (stack != 255) stack = stack - 1;

        result = result & parseExpression(buff, idx, stack, varTable);

        word = nextWord(buff, idx);
        if (@word != 59) error("for expected 'sc2' got " & word);

        result = result & "    jz for_" & flowidx & "_end\n";

        if (stack != 255) stack = stack - 1;

        last = parseExpression(buff, idx, stack, varTable);

        if (stack != 255) stack = stack - 1;

        word = nextWord(buff, idx);
        if (word != ")") error("for expected ')'");

        result = result & parseBlock(buff, idx, stack, varTable, 0);

        result = result & last & "    disc 0\n    jmp for_" & flowidx & "_loop\nfor_" & flowidx & "_end:\n";

        stack = oldstack;

        return result;
    }

    idx = dup(lastidx);

    return "";
}

fn parseBuiltin(buff, idx, stack, varTable) {
    var lastidx = dup(idx);
    var word = nextWord(buff, idx);
    var result = "";

    if (word == "return") {
        result = parseExpression(buff, idx, stack, varTable);

        for (0; stack > 1; stack = stack - 1) {
            result = result & "    disc 1\n";
        }

        stack = 255;

        return result & "    ret\n";
    }

    if (word == "disc") {
        result = parseExpression(buff, idx, stack, varTable);

        if (stack != 255) stack = stack - 1;

        return result & "    disc 0\n";
    }

    if (word == "asm") {
        word = nextWord(buff, idx);

        return "    " & ((word + 1) - 1) & "\n";
    }


    idx = dup(lastidx);

    return "";
}

fn parseFactor(buff, idx, stack, varTable) {
    var lastidx = dup(idx);
    var word = nextWord(buff, idx);
    var result = "";

    if (word == "(") {
        result = parseExpression(buff, idx, stack, varTable);

        word = nextWord(buff, idx);

        if (word == ")") {
            return result;
        }
    }

    if (word == "@") {
       result = parseFactor(buff, idx, stack, varTable);

       return result & "    getb\n";
    }

    if (_StringIsNum(word)) {
        if (stack != 255) stack = stack + 1;
        return "    push " & word & "\n";
    }

    if ((@word == 34) && (_StringEndsWith(word, @34))) {
        if (stack != 255) stack = stack + 1;
        return "    push " & word & "\n";
    }

    var newWord = dup(word);

    while (_StringLength(newWord) < 20) {
        newWord = newWord & @0;
    }

    var variable = _TableGet(varTable, newWord);
    var index = 0;

    if (variable != "") {
        index = stack - @variable;
        index = toString(index);

        if (stack != 255) stack = stack + 1;

        return "    copy " & index & "\n";
    }

    var next = nextWord(buff, idx);
    var oldStack = dup(stack);
    var tmp = @34;

    if (next == "(") {
        result = parseCall(buff, idx, stack, varTable);
        next = nextWord(buff, idx);

        if (next == ")") {
            if (word == "dup") {
                return result & "    dup 0\n    disc 1\n";
            } else if (@word == 95) {
                word = word + 1;
                word = tmp & word & tmp;
            }

            if (oldStack != 255) stack = oldStack + 1;

            return result & "    call " & word & "\n";
        }
    }

    idx = dup(lastidx);

    return "";
}

fn parseTerm(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseFactor(buff, idx, stack, varTable);

    while (done == 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == "*") {
            term = parseFactor(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    mul\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "/") {
            term = parseFactor(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    div\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "%") {
            term = parseFactor(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    mod\n";
            if (stack != 255) stack = stack - 1;
        } else {
            done = 1;
            idx = dup(lastidx);
        }
    }

    return result;
}

fn parseSum(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseTerm(buff, idx, stack, varTable);

    while (done == 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == "-") {
            term = parseTerm(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    sub\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "+") {
            term = parseTerm(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    add\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "&") {
            term = parseTerm(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    cat\n";
            if (stack != 255) stack = stack - 1;
        } else {
            done = 1;
            idx = dup(lastidx);
        }
    }

    return result;
}

fn parseExpression(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseSum(buff, idx, stack, varTable);

    while (done == 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == "==") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    eq\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "<") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    lt\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == ">") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    gt\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "=") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    set\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "!=") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    eq\n    not\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "&&") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    and\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "||") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    or\n";
            if (stack != 255) stack = stack - 1;
        } else {
            done = 1;
            idx = dup(lastidx);
        }
    }

    return result;
}

fn parseCall(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseExpression(buff, idx, stack, varTable);

    while (done == 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == ",") {
            term = parseExpression(buff, idx, stack, varTable);
            result = result & term;
        } else {
            done = 1;
            idx = dup(lastidx);
        }
    }

    return result;
}

fn verifyStmtStack(stack, start) {
    if (stack == 255) return "";

    if (stack + 1 == start) {
        if (stack != 255) stack = stack - 1;
        return "    disc 0\n";
    }

    return "";
}

fn parseStmt(buff, idx, stack, varTable) {
    var lastidx;
    var parsed = "";
    var next = "";
    var oldStack = dup(stack);

    lastidx = dup(idx);

    parsed = parseExpression(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           parsed = parsed & verifyStmtStack(stack, oldStack);
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseBuiltin(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           parsed = parsed & verifyStmtStack(stack, oldStack);
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseVar(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseFlow(buff, idx, stack, varTable);

    if (parsed != "") {
        return parsed;
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    return "";
}

fn parseBlock(buff, idx, stack, varTable, function) {
    var old = dup(idx);

    var word = nextWord(buff, idx);

    var oldStack = dup(stack);
    var code = "";
    var done = 0;
    var stmtdata;
    var lastidx;
    var stackCopy;

    var tableCopy = dup(varTable);

    if (word != "{") {
        idx = dup(old);

        var result = parseStmt(buff, idx, stack, varTable);

        if ((stack != 255) && (function == 0)) {
            for (0; stack > oldStack; stack = stack - 1) {
                result = result & "    disc 0\n";
            }
        }

        stack = oldStack;

        varTable = dup(tableCopy);

        return result;
    }

    while (done == 0) {
        lastidx = dup(idx);
        word = nextWord(buff, idx);
        stackCopy = dup(stack);

        if (word != "}") {
            if (stack == 255) {
                print(code);

                error("Unreacable code after return");
            }

            if (word == "") error("Early EOF Encountered");

            idx = dup(lastidx);
            stmtdata = parseStmt(buff, idx, stack, varTable);

            if (stmtdata == "") {
                done = 1;
            }

            code = code & stmtdata;
        } else {
            done = 1;
        }
    }

    varTable = dup(tableCopy);

    if ((stack != 255) && (function == 0)) {
        for (0; stack > oldStack; stack = stack - 1) {
            code = code & "    disc 0\n";
        }
    }

    stack = oldStack;

    return code;
}

fn parseFunction(buff, idx) {
    var word;
    
    word = nextWord(buff, idx);

    if (word != "fn") error("Expected 'fn' got '" & word & "'");
    var name = nextWord(buff, idx);

    word = nextWord(buff, idx);
    if (word != "(") error("Expected '(' got '" & word & "'");

    print("FUNC: " & name & "\n");

    var done = 0;
    var stack = 0;
    var varTable = _TableCreate(20, 1);

    while (done == 0) {
        word = nextWord(buff, idx);

        if (word != ")") {
            while (_StringLength(word) < 20) {
                word = word & @0;
            }

            if (stack != 255) stack = stack + 1;

            _TablePut(varTable, word, @stack);

            word = nextWord(buff, idx);

            if (word == ")") {
                done = 1;
            }
        } else {
            done = 1;
        }
    }

    if (word != ")") error("Expected ')' got '" & word & "'");

    var block = parseBlock(buff, idx, stack, varTable, 1);

    if (block == "") return "";

    return name & ":\n" & block;
}

fn parseFile(buff, idx) {
    var code = "    call main\n    sys 1\n";
    var func = "";
    var word = "";
    var done = 0;
    var lastidx = 0;

    while (done == 0) {
        lastidx = dup(idx);
        word = nextWord(buff, idx);

        if (word == "fn") {
            idx = dup(lastidx);
    
            func = parseFunction(buff, idx);

            code = code & func;
        } else if (word == "") {
            done = 1;
        } else {
            print(code & "\n");
            error("Invalid word Encountered: '" & word & "'");
        }
    }

    return code;
}

fn split(conts, delim) {
    var done = 0;
    var start = dup(conts);
    var idx = 0;
    var chars;
    var delimSize = _StringLength(delim);

    while (done == 0) {
        chars = dup(conts);
        chars = setSize(chars, delimSize);

        if (chars == delim) {
            start = setSize(start, idx);
            conts = conts + 1;

            return start;
        }

        if (conts == "") {
            done = 1;
        }

        conts = conts + 1;
        idx = idx + 1;
    }

    return start;
}

fn remcomment(line) {
   return split(line, @47 & @47);
}

fn preprocess(name, conts) {
    print("PRE: '" & name & "'\n");

    var nl = "\n";
    var result = "";
    var line;
    var newName;
    var file;
    var buff;

    for (line = split(conts, nl); (conts != "") || (line != ""); line = split(conts, nl)) {
         if (_StringStartsWith(line, "#include")) {
             newName = line + 10;
             newName = newName - 1;

             file = open(newName);
             buff = read(file, fileSize(newName));
             close(file);

             result = result & preprocess(newName, buff) & "\n";
         } else {
             result = result & remcomment(line) & "\n";
         }
    }

    return result;
}


fn main() {
    setupLibLoad();
    loadLib("/libs/string.ell");
    loadLib("/libs/asm.ell");

    var fileName = getArg(1);
    var fullName = fileName & ".asm";
    var outName = "out.eep";

    if (getArg(2) != "") {
       outName = getArg(2);
    }

    var file = open(fileName);

    var buff = read(file, fileSize(fileName));
    var idx = 0;

    print("EON: " & fileName & "\n");

    close(file);

    var asmTmp = createOpen(fullName);

    var conts = preprocess(fileName, buff);

    write(asmTmp, parseFile(conts, idx));

    close(asmTmp);

    _asmFile(fullName, outName);

    return 0;
}
