#include "/libs/inc/sys.eon"
#include "/libs/inc/libload.eon"

fn isWhitespace(char) {
    // returns 1 if char is whitespace
    if (@char == 32) return 1; // space
    if (@char == 10) return 1; // lf
    if (@char == 11) return 1; // tab
    if (@char == 13) return 1; // cr

    return 0;
}

fn single(char) {
    // returns 1 if char should be a whole word
    if (@char == 59) return 1;  // ;
    if (@char == 123) return 1; // {
    if (@char == 125) return 1; // }
    if (@char == 40) return 1;  // (
    if (@char == 41) return 1;  // )
    if (@char == 44) return 1;  // ,
    if (@char == 64) return 1;  // @

    return 0;
}

fn setSize() {
    // sets the size of a string
    asm "size";
    asm "ret";
}

fn nextWord(buff, idx) {
    // gets the next word in a buffer
    var oldidx = dup(idx);
    var copy = dup(buff) + idx;
    var length = 0;
    var done = 0;
    var ws = 0;
    var word = 1;
    var plen = 0;
    var isQuote = 0;

    if (isWhitespace(copy)) {
        word = 0;
    }

    if (@copy == 34) { // "
        length += 1;
        idx += 1;
        isQuote = 1;
    } else if (single(copy)) {
        idx += 1;
        copy = setSize(copy, 1);

        return copy;
    }

    // find the next word
    while (done == 0) {
        copy += length - plen;
        plen = dup(length);
        if (copy == "") done = 1;

        if (@copy == 92) { // backslash
            // ignore next char backslash
            length += 2;
            idx += 2;
        } else {
            ws = isWhitespace(copy);
            if (isQuote) {
                if (@copy == 34) { // "
                    if (length > 0) {
                        done = 1;
                        length += 1;
                        idx += 1;
                    }
                }
            } else if (single(copy)) {
               if (length == 0) {
                   idx += 1;
   
                   copy = setSize(dup(buff) + oldidx, 1);

                   return copy;
               }

               done = 1;
            }

            if (isQuote) {
                ws = 0;
            }

            if (done == 0) {
                if (copy == "") done = 1;

                if ((ws == 1) && (word == 0)) {
                    idx += 1;
                    oldidx += 1;
                    copy += 1;
                } else if ((ws == 0) && (word == 0)) {
                    word = 1;
                    if (@copy == 34) {
                        isQuote = 1;
                    }
                } else if ((ws == 1) && (word == 1)) {
                    done = 1;
                    word = 0;
                }

                if (word) {
                    length += 1;
                    idx += 1;
                }
            }
        }
    }
    
    copy = setSize(dup(buff) + oldidx, length);
    
    var result = "";
    var ch = "";
    var tmp = "";
    for (0; copy != ""; copy += 1) {
        ch = @copy;
        result &= @ch;
        if (ch == 92) {
            result -= 1;
            copy += 1;
            if (@copy == 110) {
                result &= @92;
                result &= @110;
            } else if (@copy == 114) {
                result &= @92;
                result &= @114;
            } else if (@copy == 116) {
                result &= @92;
                result &= @116;
            } else {
                tmp = @copy;
                result &= @tmp;
            }
        }
    }

    return result;
}

fn parseVar(buff, idx, stack, varTable) {
    // parses a var statment:
    // var i [ = v ]

    var lastidx = dup(idx);
    var word = nextWord(buff, idx);
    var next = "";
    var oldidx;

    if (word == "var") {
        word = nextWord(buff, idx);

        if (stack != 255) stack += 1;

        while (_StringLength(word) < 20) {
            word = word & @0;
        }

        _TablePut(varTable, word, @stack);

        oldidx = dup(idx);

        next = nextWord(buff, idx);

        if (next == "=") {
           if (stack != 255) stack -= 1;

            return parseExpression(buff, idx, stack, varTable);
        }

        idx = oldidx;

        return "push 0\n";
    }

    idx = lastidx;

    return "";
}

fn toString(number) {
    // converts a number to a string

    if (number == 0) {
        return "0";
    }

    var result = "";
    var tmp = "";

    for (0; number > 0; number = number / 10) {
        tmp = @(48 + (number % 10));
        result = tmp & result;
    }

    return result;
}

fn parseFlow(buff, idx, stack, varTable) {
    // parses a block statment:
    // if (expr) block
    // while (expr) block
    // for (expr; expr; expr) block

    var lastidx = dup(idx);
    var oldstack = dup(stack);
    var flowidx = toString(lastidx);
    var tableCopy = dup(varTable);
    var word = nextWord(buff, idx);
    var result = "";
    var last = "";

    if (word == "if") {
        word = nextWord(buff, idx);
        if (word == "(") {
            result &= parseExpression(buff, idx, stack, varTable);
            word = nextWord(buff, idx);
            if (word == ")") {
                if (stack != 255) stack -= 1;
                result &= "jz if_" & flowidx & "_else\n";

                result &= parseBlock(buff, idx, stack, varTable, 0);

                stack = dup(oldstack);

                last = dup(idx);

                word = nextWord(buff, idx);
                if (word == "else") {
                    result &= "jmp if_" & flowidx & "_end\n";
                    result &= "if_" & flowidx & "_else:\n";
                    result &= parseBlock(buff, idx, stack, varTable, 0);
                    result &= "if_" & flowidx & "_end:\n";

                    stack = oldstack;
                } else {
                    result &= "if_" & flowidx & "_else:\n";
                    idx = last;
                }

                stack = oldstack;

                return result;
            }
        }
    }

    if (word == "while") {
        word = nextWord(buff, idx);

        result = "while_" & flowidx & "_loop:\n";
        if (word != "(") error("for expected '('");

        result &= parseExpression(buff, idx, stack, varTable);
        result &= "jz while_" & flowidx & "_end\n";
        if (stack != 255) stack -= 1;

        word = nextWord(buff, idx);
        if (@word != ")") error("for expected ')' got " & word);

        result &= parseBlock(buff, idx, stack, varTable, 0);

        result &= "jmp while_" & flowidx & "_loop\nwhile_" & flowidx & "_end:\n";

        stack = oldstack;

        return result;
    }

    if (word == "for") {
        word = nextWord(buff, idx);
        if (word != "(") error("for expected '('");

        result = parseStmt(buff, idx, stack, varTable);

        result &= "for_" & flowidx & "_loop:\n";

        result &= parseExpression(buff, idx, stack, varTable);

        word = nextWord(buff, idx);
        if (@word != 59) error("for expected 'sc2' got " & word);

        result &= "jz for_" & flowidx & "_end\n";

        if (stack != 255) stack -= 1;

        last = parseExpression(buff, idx, stack, varTable);

        if (stack != 255) stack -= 1;

        word = nextWord(buff, idx);
        if (word != ")") error("for expected ')'");

        result &= parseBlock(buff, idx, stack, varTable, 0);

        result &= last & "disc 0\njmp for_" & flowidx & "_loop\nfor_" & flowidx & "_end:\n";

        if (stack != 255) {
            for (0; stack > oldstack; stack = stack - 1) {
                result &= "disc 0\n";
            }
        }

        stack = oldstack;
        varTable = tableCopy;

        return result;
    }

    idx = lastidx;

    return "";
}

fn parseBuiltin(buff, idx, stack, varTable) {
    // parses a builtin expression:
    // return expr
    // asm "expr"

    var lastidx = dup(idx);
    var word = nextWord(buff, idx);
    var result = "";

    if (word == "return") {
        result = parseExpression(buff, idx, stack, varTable);

        for (0; stack > 1; stack -= 1) {
            result &= "disc 1\n";
        }

        stack = 255;

        return result & "ret\n";
    }

    if (word == "asm") {
        word = nextWord(buff, idx);

        return ((word + 1) - 1) & "\n";
    }


    idx = lastidx;

    return "";
}

fn parseFactor(buff, idx, stack, varTable) {
    var lastidx = dup(idx);
    var word = nextWord(buff, idx);
    var result = "";

    if (word == "return") {
        idx = lastidx;

        return "";
    }

    if (word == "(") {
        result = parseExpression(buff, idx, stack, varTable);

        word = nextWord(buff, idx);

        if (word == ")") {
            return result;
        }
    }

    if (word == "@") {
       result = parseFactor(buff, idx, stack, varTable);

       return result & "getb\n";
    }

    if (_StringIsNum(word)) {
        if (stack != 255) stack = stack + 1;
        return "push " & word & "\n";
    }

    if ((@word == 34) && (_StringEndsWith(word, @34))) {
        if (stack != 255) stack = stack + 1;
        return "push " & word & "\n";
    }

    var newWord = dup(word);

    while (_StringLength(newWord) < 20) {
        newWord = newWord & @0;
    }

    var variable = _TableGet(varTable, newWord);
    var index = 0;

    if (variable != "") {
        index = stack - @variable;
        index = toString(index);

        if (stack != 255) stack = stack + 1;

        return "copy " & index & "\n";
    }

    var next = nextWord(buff, idx);
    var oldStack = dup(stack);
    var tmp = @34;

    if (next == "(") {
        result = parseCall(buff, idx, stack, varTable);
        next = nextWord(buff, idx);

        if (next == ")") {
            if (word == "dup") {
                return result & "dup 0\ndisc 1\n";
            } else if (@word == 95) {
                word = word + 1;
                word = tmp & word & tmp;
            }

            if (oldStack != 255) stack = oldStack + 1;

            return result & "call " & word & "\n";
        }
    }

    idx = lastidx;

    return "";
}

fn parseTerm(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseFactor(buff, idx, stack, varTable);

    while (done == 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == "*") {
            term = parseFactor(buff, idx, stack, varTable);
            result &= term;
            result &= "mul\n";
            if (stack != 255) stack -= 1;
        } else if (word == "/") {
            term = parseFactor(buff, idx, stack, varTable);
            result &= term;
            result &= "div\n";
            if (stack != 255) stack -= 1;
        } else if (word == "%") {
            term = parseFactor(buff, idx, stack, varTable);
            result &= term;
            result &= "mod\n";
            if (stack != 255) stack -= 1;
        } else {
            done = 1;
            idx = lastidx;
        }
    }

    return result;
}

fn parseSum(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseTerm(buff, idx, stack, varTable);

    while (done == 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == "-") {
            term = parseTerm(buff, idx, stack, varTable);
            result &= term;
            result &= "sub\n";
            if (stack != 255) stack -= 1;
        } else if (word == "+") {
            term = parseTerm(buff, idx, stack, varTable);
            result &= term;
            result &= "add\n";
            if (stack != 255) stack -= 1;
        } else if (word == "&") {
            term = parseTerm(buff, idx, stack, varTable);
            result &= term;
            result &= "cat\n";
            if (stack != 255) stack -= 1;
        } else {
            done = 1;
            idx = lastidx;
        }
    }

    return result;
}

fn parseExpression(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseSum(buff, idx, stack, varTable);

    while (done == 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == "==") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term;
            result &= "eq\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "<") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term;
            result &= "lt\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == ">") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term;
            result &= "gt\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "=") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term;
            result &= "set\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "+=") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term;
            result &= "copy 1\n"; // a b a b
            result &= "copy 1\n"; // a b a b
            result &= "add\n";    // a b a+b
            result &= "disc 1\n"; // a a+b
            result &= "set\n";    // a
            if (stack != 255) stack = stack - 1;
        } else if (word == "&=") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term; // b a
            result &= "copy 1\n"; // a b a b
            result &= "copy 1\n"; // a b a b
            result &= "cat\n";    // a b a&b
            result &= "disc 1\n"; // a a&b
            result &= "set\n";    // a 
            if (stack != 255) stack = stack - 1;
        } else if (word == "-=") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term;
            result &= "copy 1\n"; // a b a b
            result &= "copy 1\n"; // a b a b
            result &= "sub\n";    // a b a-b
            result &= "disc 1\n"; // a a-b
            result &= "set\n";    // a
            if (stack != 255) stack = stack - 1;
        } else if (word == "!=") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term;
            result &= "eq\nnot\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "&&") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term;
            result &= "and\n";
            if (stack != 255) stack = stack - 1;
        } else if (word == "||") {
            term = parseSum(buff, idx, stack, varTable);
            result &= term;
            result &= "or\n";
            if (stack != 255) stack = stack - 1;
        } else {
            done = 1;
            idx = lastidx;
        }
    }

    return result;
}

fn parseCall(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseExpression(buff, idx, stack, varTable);

    while (done == 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == ",") {
            term = parseExpression(buff, idx, stack, varTable);
            result &= term;
        } else {
            done = 1;
            idx = lastidx;
        }
    }

    return result;
}

fn verifyStmtStack(stack, start) {
    if (stack == 255) return "";

    if (stack + 1 == start) {
        if (stack != 255) stack = stack - 1;
        return "disc 0\n";
    }

    return "";
}

fn parseStmt(buff, idx, stack, varTable) {
    var lastidx;
    var parsed = "";
    var next = "";
    var oldStack = dup(stack);

    lastidx = dup(idx);

    parsed = parseExpression(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           parsed = parsed & verifyStmtStack(stack, oldStack);
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseBuiltin(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           parsed = parsed & verifyStmtStack(stack, oldStack);
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseVar(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseFlow(buff, idx, stack, varTable);

    if (parsed != "") {
        return parsed;
    }

    idx = lastidx;
    stack = oldStack;

    return "";
}

fn parseBlock(buff, idx, stack, varTable, function) {
    var old = dup(idx);

    var word = nextWord(buff, idx);

    var oldStack = dup(stack);
    var code = "";
    var done = 0;
    var stmtdata;
    var lastidx;
    var stackCopy;

    var tableCopy = dup(varTable);

    if (word != "{") {
        idx = dup(old);

        var result = parseStmt(buff, idx, stack, varTable);

        if ((stack != 255) && (function == 0)) {
            for (0; stack > oldStack; stack = stack - 1) {
                result &= "disc 0\n";
            }
        }

        stack = oldStack;

        varTable = dup(tableCopy);

        return result;
    }

    while (done == 0) {
        lastidx = dup(idx);
        word = nextWord(buff, idx);
        stackCopy = dup(stack);

        if (word != "}") {
            if (stack == 255) {
                error("Code after return");
            }

            if (word == "") error("Early EOF Encountered");

            idx = dup(lastidx);
            stmtdata = parseStmt(buff, idx, stack, varTable);

            if (stmtdata == "") {
                done = 1;
            }

            code = code & stmtdata;
        } else {
            done = 1;
        }
    }

    varTable = tableCopy;

    if ((stack != 255) && (function == 0)) {
        for (0; stack > oldStack; stack = stack - 1) {
            code = code & "disc 0\n";
        }
    }

    stack = oldStack;

    return code;
}

fn parseFunction(buff, idx) {
    var word;
    
    word = nextWord(buff, idx);

    if (word != "fn") error("Expected 'fn' got '" & word & "'");
    var name = nextWord(buff, idx);

    word = nextWord(buff, idx);
    if (word != "(") error("Expected '(' got '" & word & "'");

    var done = 0;
    var stack = 0;
    var varTable = _TableCreate(20, 1);

    while (done == 0) {
        word = nextWord(buff, idx);

        if (word != ")") {
            while (_StringLength(word) < 20) {
                word = word & @0;
            }

            if (stack != 255) stack = stack + 1;

            _TablePut(varTable, word, @stack);

            word = nextWord(buff, idx);

            if (word == ")") {
                done = 1;
            }
        } else {
            done = 1;
        }
    }

    if (word != ")") error("Expected ')' got '" & word & "'");

    var block = parseBlock(buff, idx, stack, varTable, 1);

    if (block == "") return "";

    return name & ":\n" & block;
}

fn parseFile(buff, idx) {
    var code = "call main\nsys 1\n";
    var func = "";
    var word = "";
    var done = 0;
    var lastidx = 0;

    while (done == 0) {
        lastidx = dup(idx);
        word = nextWord(buff, idx);

        if (word == "fn") {
            idx = dup(lastidx);
    
            func = parseFunction(buff, idx);

            code = code & func;
        } else if (word == "") {
            done = 1;
        } else {
            error("Invalid word Encountered: '" & word & "'");
        }
    }

    return code;
}

fn split(conts, delim) {
    var done = 0;
    var start = dup(conts);
    var idx = 0;
    var chars;
    var delimSize = _StringLength(delim);

    while (done == 0) {
        chars = dup(conts);
        chars = setSize(chars, delimSize);

        if (chars == delim) {
            start = setSize(start, idx);
            conts = conts + 1;

            return start;
        }

        if (conts == "") {
            done = 1;
        }

        conts = conts + 1;
        idx = idx + 1;
    }

    return start;
}

fn remcomment(line) {
   return split(line, @47 & @47);
}

fn preprocess(name, conts) {
    print("EON: '" & name & "'\n");

    var nl = "\n";
    var result = "";
    var newName;
    var file;
    var buff;

    for (var line = split(conts, nl); (conts != "") || (line != ""); line = split(conts, nl)) {
        if (_StringStartsWith(line, "#include")) {
            newName = line + 10;
            newName = newName - 1;

            file = open(newName);
            buff = read(file, fileSize(newName));
            close(file);

            result &= preprocess(newName, buff) & "\n";
        } else {
            result &= remcomment(line) & "\n";
        }
    }

    return result;
}

fn main() {
    setupLibLoad();
    loadLib("/libs/string.ell");
    loadLib("/libs/asm.ell");

    var fileName = getArg(1);
    var fullName = fileName & ".asm";
    var outName = "out.eep";

    if (getArg(2) != "") {
       outName = getArg(2);
    }

    var file = open(fileName);

    var buff = read(file, fileSize(fileName));
    var idx = 0;

    close(file);

    var asmTmp = createOpen(fullName);

    var conts = preprocess(fileName, buff);

    write(asmTmp, parseFile(conts, idx));

    close(asmTmp);

    _asmFile(fullName, outName);

    return 0;
}
