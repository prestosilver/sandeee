#include "content/eon/libs/asm.eon"
#include "content/eon/libs/libload.eon"

fn isWhitespace(char) {
    if (@char == 32) return 1;
    if (@char == 10) return 1;
    if (@char == 11) return 1;
    if (@char == 13) return 1;

    return 0;
}

fn single(char) {
    if (@char == 59) return 1;
    if (@char == 123) return 1;
    if (@char == 125) return 1;
    if (@char == 40) return 1;
    if (@char == 41) return 1;
    if (@char == 44) return 1;

    return 0;
}

fn setSize(string, length) {
    asm "size";
    asm "ret";
}

fn nextWord(buff, idx) {
    var copy = dup(buff) + idx;
    var length = 0;
    var done = 0;
    var ws = 0;
    var char = "";
    var word = 1;
    if (isWhitespace(copy)) {
        word = 0;
    }

    if (@copy == 34) {
        length = length + 1;
        idx = idx + 1;
    } else if (single(copy)) {
        idx = idx + 1;
        copy = setSize(copy, 1);

        return copy;
    }

    for (0; done == 0; 0) {
        char = dup(copy) + length;
        char = setSize(char, 1);
        ws = isWhitespace(char);
        if ((@copy == 34) && (@char == 34)) {
            length = length + 1;
            idx = idx + 1;
            if (length > 1) {
                done = 1;
            }
        } else if (single(char)) {
            if (length == 0) {
                idx = idx + 1;
                
                return char;
            }

            done = 1;
        }

        if ((@copy == 34)) {
            ws = (@char == 34);

            if (length < 2) {
                ws = 0;
            }
        }

        if (done == 0) {
            if (char == "") done = 1;

            if ((ws == 1) && (word == 0)) {
                idx = idx + 1;
                copy = copy + 1;
            } else if ((ws == 0) && (word == 0)) {
                word = 1;
            } else if ((ws == 1) && (word == 1)) {
                done = 1;
                word = 0;
            }

            if (word) {
                length = length + 1;
                idx = idx + 1;
            }
        }
    }

    copy = setSize(copy, length);

    return copy;
}

fn parseVar(buff, idx, stack, varTable) {
   var lastidx = dup(idx);
   var word = nextWord(buff, idx);
   var next = "";
   var oldidx;

   if (word == "var") {
       word = nextWord(buff, idx);

       stack = stack + 1;

       for (0; _StringLength(word) < 20; 0) {
           word = word & @0;
       }

       tablePut(varTable, word, @stack);

       oldidx = dup(idx);

       next = nextWord(buff, idx);

       if (next == "=") {
            stack = stack - 1;

            return parseExpression(buff, idx, stack, varTable);
       }

       idx = dup(oldidx);

       return "    push 0\\n";
   }

   idx = dup(lastidx);

   return "";
}

fn parseIf(buff, idx, stack, varTable) {
   var lastidx = dup(idx);
   var ifidx = "" & lastidx;
   var word = nextWord(buff, idx);
   var result = "";

   if (word == "if") {
       word = nextWord(buff, idx);
       if (word == "(") {
           result = result & parseExpression(buff, idx, stack, varTable);
           word = nextWord(buff, idx);
           if (word == ")") {
               stack = stack - 1;
               result = result & "    jz blk_" & ifidx & "\\n";

               result = result & parseBlock(buff, idx, stack, varTable);

               return result & "blk_" & ifidx & ":\\n";
           }
       }
   }

   idx = dup(lastidx);

   return "";
}

fn parseBuiltin(buff, idx, stack, varTable) {
   var lastidx = dup(idx);
   var word = nextWord(buff, idx);
   var result = "";

   if (word == "return") {
       result = parseExpression(buff, idx, stack, varTable);

       for (0; stack > 1; stack = stack - 1) {
           result = result & "    disc 1\\n";
       }

       stack = 255;

       return result & "    ret\\n";
   }

   if (word == "disc") {
       result = parseExpression(buff, idx, stack, varTable);

       stack = stack - 1;

       return result & "    disc 0\\n";
   }
   if (word == "asm") {
       word = nextWord(buff, idx);

       return "    " & ((word + 1) - 1) & "\\n";
   }


   idx = dup(lastidx);

   return "";
}

fn parseFactor(buff, idx, stack, varTable) {
   var lastidx = dup(idx);
   var word = nextWord(buff, idx);
   var result = "";

   if (word == "(") {
       result = parseExpression(buff, idx, stack, varTable);

       word = nextWord(buff, idx);

       if (word == ")") {
           return result;
       }
   }

   if (_StringIsNum(word)) {
       stack = stack + 1;
       return "    push " & word & "\\n";
   }

   if ((@word == 34) && (_StringEndsWith(word, @34))) {
       stack = stack + 1;
       return "    push " & word & "\\n";
   }

   var newWord = dup(word);

   for (0; _StringLength(newWord) < 20; 0) {
       newWord = newWord & @0;
   }

   var variable = tableGet(varTable, newWord);
   var index = 0;

   if (variable != "") {
       index = stack - @variable;
       index = index + @"0";

       stack = stack + 1;

       return "    copy " &  @index & "\\n";
   }

   var next = nextWord(buff, idx);
   var oldStack = dup(stack);

   if (next == "(") {
       result = parseCall(buff, idx, stack, varTable);
       next = nextWord(buff, idx);

       if (next == ")") {
          if (word == "dup") {
               return result & "    dup 0\\n    disc 1\\n";
          }

          stack = oldStack + 1;

          return result & "    call " & word & "\\n";
       }
   }

   idx = dup(lastidx);

   return "";
}

fn parseTerm(buff, idx, stack, varTable) {
   var term = "";
   var word = "";
   var done = 0;

   var lastidx;

   var result = parseFactor(buff, idx, stack, varTable);

   for (0; done == 0; 0) {
       lastidx = dup(idx);

       word = nextWord(buff, idx);

       if (word == "*") {
           term = parseFactor(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    mul\\n";
           stack = stack - 1;
       } else if (word == "/") {
           term = parseFactor(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    div\\n";
           stack = stack - 1;
       } else {
           done = 1;
           idx = dup(lastidx);
       }
   }

   return result;
}

fn parseSum(buff, idx, stack, varTable) {
   var term = "";
   var word = "";
   var done = 0;

   var lastidx;

   var result = parseTerm(buff, idx, stack, varTable);

   for (0; done == 0; 0) {
       lastidx = dup(idx);

       word = nextWord(buff, idx);

       if (word == "-") {
           term = parseTerm(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    sub\\n";
           stack = stack - 1;
       } else if (word == "+") {
           term = parseTerm(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    add\\n";
           stack = stack - 1;
       } else {
           done = 1;
           idx = dup(lastidx);
       }
   }

   return result;
}

fn parseExpression(buff, idx, stack, varTable) {
   var term = "";
   var word = "";
   var done = 0;

   var lastidx;

   var result = parseSum(buff, idx, stack, varTable);

   for (0; done == 0; 0) {
       lastidx = dup(idx);

       word = nextWord(buff, idx);

       if (word == "==") {
           term = parseSum(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    eq\\n";
           stack = stack - 1;
       } else if (word == "<") {
           term = parseSum(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    lt\\n";
           stack = stack - 1;
       } else if (word == ">") {
           term = parseSum(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    gt\\n";
           stack = stack - 1;
       } else if (word == "=") {
           term = parseSum(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    set\\n";
           stack = stack - 1;
       } else if (word == "&") {
           term = parseSum(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    cat\\n";
           stack = stack - 1;
       } else if (word == "!=") {
           term = parseSum(buff, idx, stack, varTable);
           result = result & term;
           result = result & "    eql\\n    not\\n";
           stack = stack - 1;
       } else {
           done = 1;
           idx = dup(lastidx);
       }
   }

   return result;
}

fn parseCall(buff, idx, stack, varTable) {
   var term = "";
   var word = "";
   var done = 0;

   var lastidx;

   var result = parseExpression(buff, idx, stack, varTable);

   for (0; done == 0; 0) {
       lastidx = dup(idx);

       word = nextWord(buff, idx);

       if (word == ",") {
           term = parseExpression(buff, idx, stack, varTable);
           result = result & term;
       } else {
           done = 1;
           idx = dup(lastidx);
       }
   }

   return result;
}

fn verifyStmtStack(stack, start) {
    if (stack == 255) return "";

    if (stack + 1 == start) {
        stack = stack - 1;
        return "    disc 0\\n";
    }

    return "";
}

fn parseStmt(buff, idx, stack, varTable) {
    var lastidx;
    var parsed = "";
    var next = "";
    var oldStack = dup(stack);

    lastidx = dup(idx);

    parsed = parseExpression(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           parsed = parsed & verifyStmtStack(stack, oldStack);
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseBuiltin(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           parsed = parsed & verifyStmtStack(stack, oldStack);
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseVar(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseIf(buff, idx, stack, varTable);

    if (parsed != "") {
        return parsed;
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    return "";
}

fn len(string) {
    asm "len";
    asm "ret";
}

fn parseBlock(buff, idx, stack, varTable) {
    var word = nextWord(buff, idx);

    if (word != "{") error("Expected '{' got '" & word & "'");

    var code = "";
    var done = 0;
    var stmtdata;
    var word = "";
    var lastidx;
    var stackCopy;

    var tableCopy = dup(varTable);
    var oldStack = dup(stack);

    for (0; done == 0; 0) {
        lastidx = dup(idx);
        word = nextWord(buff, idx);
        stackCopy = dup(stack);

        if (word != "}") {
            if (stack == 255) error("Unreacable code after return");

            if (word == "") error("Early EOF Encountered");

            idx = dup(lastidx);
            stmtdata = parseStmt(buff, idx, stack, varTable);

            if (stmtdata == "") {
                done = 1;
            }

            code = code & stmtdata;
        } else {
            done = 1;
        }
    }

    if ((stack != 255) && (stack > oldStack)) {
        for (0; stack > oldStack; stack = stack - 1) {
            code = code & "    disc 0";
        }
    }

    stack = oldStack;

    varTable = tableCopy;

    return code;
}

fn parseFunction(buff, idx) {
    var word;
    
    word = nextWord(buff, idx);

    if (word != "fn") error("Expected 'fn' got '" & word & "'");
    var name = nextWord(buff, idx);

    word = nextWord(buff, idx);
    if (word != "(") error("Expected '(' got '" & word & "'");

    var done = 0;
    var stack = 0;
    var varTable = tableCreate(20, 1);

    for (0; done == 0; 0) {
        word = nextWord(buff, idx);

        if (word != ")") {
            for (0; _StringLength(word) < 20; 0) {
                word = word & @0;
            }

            stack = stack + 1;

            tablePut(varTable, word, @stack);

            word = nextWord(buff, idx);

            if (word == ")") {
                done = 1;
            }
        } else {
            done = 1;
        }
    }

    if (word != ")") error("Expected ')' got '" & word & "'");

    var block = parseBlock(buff, idx, stack, varTable);

    if (block == "") return "";

    return name & ":\\n" & block;
}

fn parseFile(buff, idx) {
    var code = "    call main\\n    sys 1\\n";
    var func = "";
    var word = "";
    var done = 0;
    var lastidx = 0;

    for (0; done == 0; 0) {
        lastidx = dup(idx);
        word = nextWord(buff, idx);

        if (word == "fn") {
            idx = idx - 2;
    
            func = parseFunction(buff, idx);

            code = code & func;
        } else if (word == "") {
            done = 1;
        } else {
            error("Invalid word Encountered: '" & word & "'");
        }
    }

    return code;
}

fn main() {
    setupLibLoad();
    loadLib("/libs/string.ell");

    var fileName = getArg(1);
    var file = open(fileName);

    var buff = read(file, fileSize(fileName));
    var idx = 0;

    print("EON: " & fileName & "\\n");

    close(file);

    var asmTmp = createOpen(fileName & ".asm");

    write(asmTmp, parseFile(buff, idx));

    close(asmTmp);

    var fullName = fileName & ".asm";

    asmFile(fullName, "out.eep");

    return 0;
}
