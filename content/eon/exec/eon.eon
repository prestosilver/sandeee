#include "/libs/inc/sys.eon"
#include "/libs/inc/libload.eon"

fn isWhitespace(char) {
    if (@char == 32) return 1;
    if (@char == 10) return 1;
    if (@char == 11) return 1;
    if (@char == 13) return 1;

    return 0;
}

fn single(char) {
    if (@char == 59) return 1;
    if (@char == 123) return 1;
    if (@char == 125) return 1;
    if (@char == 40) return 1;
    if (@char == 41) return 1;
    if (@char == 44) return 1;
    if (@char == 64) return 1;

    return 0;
}

fn setSize(string, length) {
    asm "size";
    asm "ret";
}

fn nextWord(buff, idx) {
    var copy = dup(buff) + idx;
    var length = 0;
    var done = 0;
    var ws = 0;
    var char = "";
    var word = 1;
    if (isWhitespace(copy)) {
        word = 0;
    }

    if (@copy == 34) {
        length = length + 1;
        idx = idx + 1;
    } else if (single(copy)) {
        idx = idx + 1;
        copy = setSize(copy, 1);

        return copy;
    }

    for (0; done == 0; 0) {
        char = dup(copy) + length;
        char = setSize(char, 1);
        if (@char == 92) {
            length = length + 2;
            idx = idx + 2;
        } else {
            ws = isWhitespace(char);
            if (@copy == 34) {
                if (@char == 34) {
                    if (length > 0) {
                        done = 1;
                        length = length + 1;
                        idx = idx + 1;
                    }
                }
            } else if (single(char)) {
               if (length == 0) {
                   idx = idx + 1;

                   return char;
               }

               done = 1;
            }

            if (@copy == 34) {
                ws = 0;
            }

            if (done == 0) {
                if (char == "") done = 1;

                if ((ws == 1) && (word == 0)) {
                    idx = idx + 1;
                    copy = copy + 1;
                } else if ((ws == 0) && (word == 0)) {
                    word = 1;
                } else if ((ws == 1) && (word == 1)) {
                    done = 1;
                    word = 0;
                }

                if (word) {
                    length = length + 1;
                    idx = idx + 1;
                }
            }
        }
    }

    copy = setSize(copy, length);
    
    var result = "";
    var ch = "";
    for (0; copy != ""; copy = copy + 1) {
        ch = @copy;
        result = result & @ch;
        if (ch == 92) {
            result = result - 1;
            copy = copy + 1;
            if (@copy == 110) {
                result = result & @92;
                result = result & @110;
            } else if (@copy == 116) {
                result = result & @92;
                result = result & @116;
            } else {
                result = result & @copy;
            }
        }
    }


    return result;
}

fn parseVar(buff, idx, stack, varTable) {
    var lastidx = dup(idx);
    var word = nextWord(buff, idx);
    var next = "";
    var oldidx;

    if (word == "var") {
        word = nextWord(buff, idx);

        stack = stack + 1;

        for (0; _StringLength(word) < 20; 0) {
            word = word & @0;
        }

        _TablePut(varTable, word, @stack);

        oldidx = dup(idx);

        next = nextWord(buff, idx);

        if (next == "=") {
            stack = stack - 1;

            return parseExpression(buff, idx, stack, varTable);
        }

        idx = dup(oldidx);

        return "    push 0\\n";
    }

    idx = dup(lastidx);

    return "";
}

fn toString(number) {
   if (number == 0) {
       return "0";
   }

   var result = "";

   for (0; number > 0; number = number / 10) {
       result = result & @(48 + (number % 10));
   }

   return result;
}

fn parseFlow(buff, idx, stack, varTable) {
    var lastidx = dup(idx);
    var oldstack = dup(stack);
    var flowidx = toString(lastidx);
    var word = nextWord(buff, idx);
    var result = "";
    var last = "";

    if (word == "if") {
        word = nextWord(buff, idx);
        if (word == "(") {
            result = result & parseExpression(buff, idx, stack, varTable);
            word = nextWord(buff, idx);
            if (word == ")") {
                stack = stack - 1;
                result = result & "    jz if_" & flowidx & "_else\\n";

                result = result & parseBlock(buff, idx, stack, varTable, 0);

                stack = oldstack;

                result = result & "    jmp if_" & flowidx & "_end\\n";
                result = result & "if_" & flowidx & "_else:\\n";

                last = dup(idx);

                word = nextWord(buff, idx);
                if (word == "else") {
                    result = result & parseBlock(buff, idx, stack, varTable, 0);

                    stack = oldstack;
                } else {
                    idx = dup(last);
                }

                result = result & "if_" & flowidx & "_end:\\n";

                return result;
            }
        }
    }

    if (word == "for") {
        word = nextWord(buff, idx);
        if (word != "(") error("for expected '('");

        result = parseExpression(buff, idx, stack, varTable);

        word = nextWord(buff, idx);
        if (@word != 59) error("for expected 'sc1' got " & word);

        result = result & "    disc 0\\nfor_" & flowidx & "_loop:\\n";
        stack = stack - 1;

        result = result & parseExpression(buff, idx, stack, varTable);

        word = nextWord(buff, idx);
        if (@word != 59) error("for expected 'sc2' got " & word);

        result = result & "    jz for_" & flowidx & "_end\\n";

        stack = stack - 1;

        last = parseExpression(buff, idx, stack, varTable);

        stack = stack - 1;

        word = nextWord(buff, idx);
        if (word != ")") error("for expected ')'");

        result = result & parseBlock(buff, idx, stack, varTable, 0);

        result = result & last & "    disc 0\\n    jmp for_" & flowidx & "_loop\\nfor_" & flowidx & "_end:\\n";

        stack = oldstack;

        return result;
    }

    idx = dup(lastidx);

    return "";
}

fn parseBuiltin(buff, idx, stack, varTable) {
    var lastidx = dup(idx);
    var word = nextWord(buff, idx);
    var result = "";

    if (word == "return") {
        result = parseExpression(buff, idx, stack, varTable);

        for (0; stack > 1; stack = stack - 1) {
            result = result & "    disc 1\\n";
        }

        stack = 255;

        return result & "    ret\\n";
    }

    if (word == "disc") {
        result = parseExpression(buff, idx, stack, varTable);

        stack = stack - 1;

        return result & "    disc 0\\n";
    }
    if (word == "asm") {
        word = nextWord(buff, idx);

        return "    " & ((word + 1) - 1) & "\\n";
    }


    idx = dup(lastidx);

    return "";
}

fn parseFactor(buff, idx, stack, varTable) {
    var lastidx = dup(idx);
    var word = nextWord(buff, idx);
    var result = "";

    if (word == "(") {
        result = parseExpression(buff, idx, stack, varTable);

        word = nextWord(buff, idx);

        if (word == ")") {
            return result;
        }
    }

    if (word == "@") {
       result = parseExpression(buff, idx, stack, varTable);

       return result & "    getb\\n";
    }

    if (_StringIsNum(word)) {
        stack = stack + 1;
        return "    push " & word & "\\n";
    }

    if ((@word == 34) && (_StringEndsWith(word, @34))) {
        stack = stack + 1;
        return "    push " & word & "\\n";
    }

    var newWord = dup(word);

    for (0; _StringLength(newWord) < 20; 0) {
        newWord = newWord & @0;
    }

    var variable = _TableGet(varTable, newWord);
    var index = 0;

    if (variable != "") {
        index = stack - @variable;
        index = index + @"0";

        stack = stack + 1;

        return "    copy " &  @index & "\\n";
    }

    var next = nextWord(buff, idx);
    var oldStack = dup(stack);

    if (next == "(") {
        result = parseCall(buff, idx, stack, varTable);
        next = nextWord(buff, idx);

        if (next == ")") {
            if (word == "dup") {
                return result & "    dup 0\\n    disc 1\\n";
            } else if (@word == 95) {
                word = word + 1;
                word = (@34) & word & (@34);
            }

            stack = oldStack + 1;

            return result & "    call " & word & "\\n";
        }
    }

    idx = dup(lastidx);

    return "";
}

fn parseTerm(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseFactor(buff, idx, stack, varTable);

    for (0; done == 0; 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == "*") {
            term = parseFactor(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    mul\\n";
            stack = stack - 1;
        } else if (word == "/") {
            term = parseFactor(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    div\\n";
            stack = stack - 1;
        } else if (word == "%") {
            term = parseFactor(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    mod\\n";
            stack = stack - 1;
        } else {
            done = 1;
            idx = dup(lastidx);
        }
    }

    return result;
}

fn parseSum(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseTerm(buff, idx, stack, varTable);

    for (0; done == 0; 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == "-") {
            term = parseTerm(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    sub\\n";
            stack = stack - 1;
        } else if (word == "+") {
            term = parseTerm(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    add\\n";
            stack = stack - 1;
        } else {
            done = 1;
            idx = dup(lastidx);
        }
    }

    return result;
}

fn parseExpression(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseSum(buff, idx, stack, varTable);

    for (0; done == 0; 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == "==") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    eq\\n";
            stack = stack - 1;
        } else if (word == "<") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    lt\\n";
            stack = stack - 1;
        } else if (word == ">") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    gt\\n";
            stack = stack - 1;
        } else if (word == "=") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    set\\n";
            stack = stack - 1;
        } else if (word == "&") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    cat\\n";
            stack = stack - 1;
        } else if (word == "!=") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    eq\\n    not\\n";
            stack = stack - 1;
        } else if (word == "&&") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    and\\n";
            stack = stack - 1;
        } else if (word == "||") {
            term = parseSum(buff, idx, stack, varTable);
            result = result & term;
            result = result & "    or\\n";
            stack = stack - 1;
        } else {
            done = 1;
            idx = dup(lastidx);
        }
    }

    return result;
}

fn parseCall(buff, idx, stack, varTable) {
    var term = "";
    var word = "";
    var done = 0;

    var lastidx;

    var result = parseExpression(buff, idx, stack, varTable);

    for (0; done == 0; 0) {
        lastidx = dup(idx);

        word = nextWord(buff, idx);

        if (word == ",") {
            term = parseExpression(buff, idx, stack, varTable);
            result = result & term;
        } else {
            done = 1;
            idx = dup(lastidx);
        }
    }

    return result;
}

fn verifyStmtStack(stack, start) {
    if (stack == 255) return "";

    if (stack + 1 == start) {
        stack = stack - 1;
        return "    disc 0\\n";
    }

    return "";
}

fn parseStmt(buff, idx, stack, varTable) {
    var lastidx;
    var parsed = "";
    var next = "";
    var oldStack = dup(stack);

    lastidx = dup(idx);

    parsed = parseExpression(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           parsed = parsed & verifyStmtStack(stack, oldStack);
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseBuiltin(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           parsed = parsed & verifyStmtStack(stack, oldStack);
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseVar(buff, idx, stack, varTable);

    if (parsed != "") {
        next = nextWord(buff, idx);

        if (@next == 59) {
           return parsed;
        }
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    parsed = parseFlow(buff, idx, stack, varTable);

    if (parsed != "") {
        return parsed;
    }

    idx = dup(lastidx);
    stack = dup(oldStack);

    return "";
}

fn parseBlock(buff, idx, stack, varTable, function) {
    var old = dup(idx);

    var word = nextWord(buff, idx);

    if (word != "{") {
        idx = dup(old);

        return parseStmt(buff, idx, stack, varTable) & "    disc 0\\n";
    }

    var code = "";
    var done = 0;
    var stmtdata;
    var lastidx;
    var stackCopy;

    var tableCopy = dup(varTable);
    var oldStack = dup(stack);

    for (0; done == 0; 0) {
        lastidx = dup(idx);
        word = nextWord(buff, idx);
        stackCopy = dup(stack);

        if (word != "}") {
            if (stack == 255) {
                print(code);

                error("Unreacable code after return");
            }

            if (word == "") error("Early EOF Encountered");

            idx = dup(lastidx);
            stmtdata = parseStmt(buff, idx, stack, varTable);

            if (stmtdata == "") {
                done = 1;
            }

            code = code & stmtdata;
        } else {
            done = 1;
        }
    }

    varTable = dup(tableCopy);

    if (stack != 255 && function == 1) {
        for (0; stack > oldStack; stack = stack - 1) {
            code = code & "    disc 0\\n";
        }
    }

    stack = oldStack;

    return code;
}

fn parseFunction(buff, idx) {
    var word;
    
    word = nextWord(buff, idx);

    if (word != "fn") error("Expected 'fn' got '" & word & "'");
    var name = nextWord(buff, idx);

    word = nextWord(buff, idx);
    if (word != "(") error("Expected '(' got '" & word & "'");

    print("FUNC: " & name & "\\n");

    var done = 0;
    var stack = 0;
    var varTable = _TableCreate(20, 1);

    for (0; done == 0; 0) {
        word = nextWord(buff, idx);

        if (word != ")") {
            for (0; _StringLength(word) < 20; 0) {
                word = word & @0;
            }

            stack = stack + 1;

            _TablePut(varTable, word, @stack);

            word = nextWord(buff, idx);

            if (word == ")") {
                done = 1;
            }
        } else {
            done = 1;
        }
    }

    if (word != ")") error("Expected ')' got '" & word & "'");

    var block = parseBlock(buff, idx, stack, varTable, 1);

    if (block == "") return "";

    return name & ":\\n" & block;
}

fn parseFile(buff, idx) {
    var code = "    call main\\n    sys 1\\n";
    var func = "";
    var word = "";
    var done = 0;
    var lastidx = 0;

    for (0; done == 0; 0) {
        lastidx = dup(idx);
        word = nextWord(buff, idx);

        if (word == "fn") {
            idx = dup(lastidx);
    
            func = parseFunction(buff, idx);

            code = code & func;
        } else if (word == "") {
            done = 1;
        } else {
            print(code & "\\n");
            error("Invalid word Encountered: '" & word & "'");
        }
    }

    return code;
}

fn split(conts, delim) {
    var done = 0;
    var start = dup(conts);
    var idx = 0;
    var chars;
    var delimSize = _StringLength(delim);

    for (0; done == 0; 0) {
        conts = conts + 1;
        idx = idx + 1;

        chars = dup(conts);
        chars = setSize(chars, delimSize);

        if (chars == delim) {
            start = setSize(start, idx);
            conts = conts + 1;

            return start;
        }
        if (conts == "") {
            done = 1;
        }
    }

    return start;
}

fn remcomment(line) {
   var start = split(line, "\/\/");

   return start;
}

fn preprocess(name, conts) {
    print("PRE: '" & name & "'\\n");

    var nl = "\\n";
    var result = "";
    var line;
    var newName;
    var file;
    var buff;

    for (line = split(conts, nl); line != 0; line = split(conts, nl)) {
         if (_StringStartsWith(line, "#include")) {
             newName = line + 10;
             newName = newName - 1;

             file = open(newName);
             buff = read(file, fileSize(newName));
             close(file);

             result = result & preprocess(newName, buff) & "\\n";
         } else {
             result = result & remcomment(line) & "\\n";
         }
    }

    return result;
}


fn main() {
    setupLibLoad();
    loadLib("/libs/string.ell");
    loadLib("/libs/asm.ell");

    var fileName = getArg(1);
    var file = open(fileName);

    var buff = read(file, fileSize(fileName));
    var idx = 0;

    print("EON: " & fileName & "\\n");

    close(file);

    var asmTmp = createOpen(fileName & ".asm");

    var conts = preprocess(fileName, buff);

    write(asmTmp, parseFile(conts, idx));

    close(asmTmp);

    var fullName = fileName & ".asm";

    _asmFile(fullName, "out.eep");

    return 0;
}
