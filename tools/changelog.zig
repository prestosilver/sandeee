const std = @import("std");
const files = @import("../src/system/files.zig");

const LOG_HEADER: []const u8 =
    \\#Style @/style.eds
    \\:logo: [@/logo.eia]
    \\
    \\-- Changelog --
    \\
    \\:h3: Note: This page is autogenerated from git commits!
    \\
    \\-- Upcoming --
    \\
;

const LOG_FOOTER: []const u8 =
    \\
    \\:center: --- EEE Sees All ---
;

pub const ChangelogStep = struct {
    step: std.Build.Step,
    output: []const u8,
    alloc: std.mem.Allocator,

    pub fn create(b: *std.Build, output: []const u8) !*ChangelogStep {
        const self = try b.allocator.create(ChangelogStep);
        self.* = .{
            .step = std.Build.Step.init(.{
                .id = .run,
                .name = try std.fmt.allocPrint(b.allocator, "ChangeLog {s}", .{output}),
                .makeFn = ChangelogStep.doStep,
                .owner = b,
            }),
            .output = output,
            .alloc = b.allocator,
        };
        return self;
    }

    fn doStep(step: *std.Build.Step, _: *std.Progress.Node) !void {
        const self: *ChangelogStep = @fieldParentPtr("step", step);
        const b = step.owner;

        var file = try std.fs.cwd().createFile(self.output, .{});
        defer file.close();

        _ = try file.write(LOG_HEADER);

        const git_log = b.run(&.{ "git", "log", "master", "--pretty=format:%h" });

        var lines = std.mem.split(u8, git_log, "\n");

        const current = b.run(&.{ "cat", "VERSION" });

        var last: []const u8 = try b.allocator.alloc(u8, 0);

        while (lines.next()) |line| {
            const file_text = try std.fmt.allocPrint(b.allocator, "{s}:VERSION", .{line});
            defer b.allocator.free(file_text);

            var tmp: u8 = 0;

            const ver = b.runAllowFail(&.{ "git", "show", file_text }, &tmp, .Ignore) catch continue;
            defer step.owner.allocator.free(ver);

            const idx = std.mem.indexOf(u8, ver, "+") orelse ver.len;
            const version = std.mem.trim(u8, ver[0..idx], "\n");

            if (!std.mem.eql(u8, version, "")) {
                if (!std.mem.eql(u8, last, version)) {
                    if (!std.mem.eql(u8, current, version)) {
                        if (!std.mem.eql(u8, last, "")) {
                            const text = try std.fmt.allocPrint(b.allocator,
                                \\
                                \\-- {s} --
                                \\
                            , .{last});
                            defer b.allocator.free(text);

                            _ = try file.write(text);
                        }
                    }
                    b.allocator.free(last);
                    last = try b.allocator.dupe(u8, version);
                }

                const change_line = b.run(&.{ "git", "log", "-1", "--pretty=format:%s", line });
                defer b.allocator.free(change_line);

                const lower_line = try std.ascii.allocLowerString(b.allocator, change_line);
                defer b.allocator.free(lower_line);

                if (!std.mem.eql(u8, change_line, "")) {
                    var ch: [2]u8 = .{ '|', '*' };
                    if (std.mem.containsAtLeast(u8, lower_line, 1, "add")) ch[1] = '+';
                    if (std.mem.containsAtLeast(u8, lower_line, 1, "impl")) ch[1] = '+';

                    if (std.mem.containsAtLeast(u8, lower_line, 1, "rem")) ch[1] = '-';
                    if (std.mem.containsAtLeast(u8, lower_line, 1, "delete")) ch[1] = '-';

                    if (std.mem.containsAtLeast(u8, lower_line, 1, "fix")) ch[1] = '!';
                    if (std.mem.containsAtLeast(u8, lower_line, 1, "update")) ch[1] = '!';
                    if (std.mem.containsAtLeast(u8, lower_line, 1, "reimpl")) ch[1] = '!';

                    if (std.mem.containsAtLeast(u8, lower_line, 1, "bump")) ch[1] = ' ';

                    if (ch[1] != ' ') {
                        _ = try file.write(&ch);
                        _ = try file.write(" ");
                        _ = try file.write(change_line);
                        _ = try file.write("\n");
                    }
                }
            }
        }

        _ = try file.write(LOG_FOOTER);
    }
};
