const std = @import("std");
const files = @import("../src/system/files.zig");

const LOG_HEADER: []const u8 =
    \\#Style @/style.eds
    \\:logo: [@/logo.eia]
    \\
    \\-- Changelog --
    \\
    \\:h3: Note: This page is autogenerated from git commits!
    \\
    \\-- Upcoming --
    \\
;

const LOG_FOOTER: []const u8 =
    \\
    \\:center: --- EEE Sees All ---
;

pub var gpa = std.heap.GeneralPurposeAllocator(.{ .stack_trace_frames = 10 }){};
pub const allocator = gpa.allocator();

pub var version_table: std.StringHashMap([]const u8) = .init(allocator);

pub fn main() !void {
    var args = try std.process.argsWithAllocator(allocator);
    _ = args.next();
    const version_path = args.next() orelse return error.MissingVersionFile;
    const version_convert_path = args.next() orelse return error.MissingConvFile;
    const output_file = args.next() orelse return error.MissingOutputFile;

    const version_convert_file = try std.fs.openFileAbsolute(version_convert_path, .{});
    var reader = version_convert_file.reader();
    while (try reader.readUntilDelimiterOrEofAlloc(allocator, '\n', 1024)) |line| {
        const comma_idx = std.mem.indexOf(u8, line, ",") orelse continue;
        try version_table.put(line[0..comma_idx], line[comma_idx + 1 ..]);
    }

    var file = try std.fs.createFileAbsolute(output_file, .{});
    defer file.close();

    _ = try file.write(LOG_HEADER);

    var child = std.process.Child.init(&.{ "git", "log", "master", "--pretty=format:%h" }, allocator);
    child.stdout_behavior = .Pipe;

    try child.spawn();

    // Wait for process to exit
    const stdout_file = child.stdout.?;
    var stdout_stream = stdout_file.reader();
    var stdout_buffer = std.ArrayList(u8).init(allocator);
    defer stdout_buffer.deinit();
    try stdout_stream.readAllArrayList(&stdout_buffer, 1 << 20);
    const term = try child.wait();
    if (term.Exited != 0) return error.GitFailed;

    var lines = std.mem.splitScalar(u8, stdout_buffer.items, '\n');

    var current: [128]u8 = undefined;

    const version_file = try std.fs.openFileAbsolute(version_path, .{});
    defer version_file.close();
    const current_len = try version_file.readAll(&current);

    var last: []const u8 = try allocator.alloc(u8, 0);

    while (lines.next()) |line| {
        const file_text = try std.fmt.allocPrint(allocator, "{s}:VERSION", .{line});
        defer allocator.free(file_text);

        var git_proc = std.process.Child.init(&.{ "git", "show", file_text }, allocator);
        git_proc.stdout_behavior = .Pipe;
        git_proc.stderr_behavior = .Ignore;
        try git_proc.spawn();

        const git_stdout_file = git_proc.stdout.?;
        var git_stdout_stream = git_stdout_file.reader();
        var git_stdout_buffer = std.ArrayList(u8).init(allocator);
        defer git_stdout_buffer.deinit();
        try git_stdout_stream.readAllArrayList(&git_stdout_buffer, 1 << 20);

        // Wait for process to exit
        const git_term = try git_proc.wait();
        if (git_term.Exited != 0) continue;

        const ver = if (version_table.get(git_stdout_buffer.items)) |ver|
            ver
        else
            git_stdout_buffer.items;

        const idx = std.mem.indexOf(u8, ver, "+") orelse ver.len;
        const version = std.mem.trim(u8, ver[0..idx], "\n");

        if (!std.mem.eql(u8, version, "")) {
            if (!std.mem.eql(u8, last, version)) {
                if (!std.mem.eql(u8, current[0..current_len], version)) {
                    if (!std.mem.eql(u8, last, "")) {
                        const text = try std.fmt.allocPrint(allocator,
                            \\
                            \\-- {s} --
                            \\
                        , .{last});
                        defer allocator.free(text);

                        _ = try file.write(text);
                    }
                }
                allocator.free(last);
                last = try allocator.dupe(u8, version);
            }

            var log_child = std.process.Child.init(&.{ "git", "log", "-1", "--pretty=format:%s", line }, allocator);
            log_child.stdout_behavior = .Pipe;

            try log_child.spawn();

            const log_stdout_file = log_child.stdout.?;
            var log_stdout_stream = log_stdout_file.reader();
            var log_stdout_buffer = std.ArrayList(u8).init(allocator);
            defer log_stdout_buffer.deinit();
            try log_stdout_stream.readAllArrayList(&log_stdout_buffer, 1 << 20);
            const change_line = log_stdout_buffer.items;

            // Wait for process to exit
            const log_term = try log_child.wait();
            if (log_term.Exited != 0) return error.GitFailed;

            const lower_line = try std.ascii.allocLowerString(allocator, change_line);
            defer allocator.free(lower_line);

            if (!std.mem.eql(u8, change_line, "")) {
                var ch: [2]u8 = .{ '|', '*' };
                if (std.mem.containsAtLeast(u8, lower_line, 1, "add")) ch[1] = '+';
                if (std.mem.containsAtLeast(u8, lower_line, 1, "impl")) ch[1] = '+';

                if (std.mem.containsAtLeast(u8, lower_line, 1, "rem")) ch[1] = '-';
                if (std.mem.containsAtLeast(u8, lower_line, 1, "delete")) ch[1] = '-';

                if (std.mem.containsAtLeast(u8, lower_line, 1, "fix")) ch[1] = '!';
                if (std.mem.containsAtLeast(u8, lower_line, 1, "update")) ch[1] = '!';
                if (std.mem.containsAtLeast(u8, lower_line, 1, "reimpl")) ch[1] = '!';

                if (std.mem.containsAtLeast(u8, lower_line, 1, "bump")) ch[1] = ' ';
                if (std.mem.containsAtLeast(u8, lower_line, 1, "meta")) ch[1] = ' ';
                if (std.mem.containsAtLeast(u8, lower_line, 1, "githide")) ch[1] = ' ';

                if (ch[1] != ' ') {
                    _ = try file.write(&ch);
                    _ = try file.write(" ");
                    _ = try file.write(change_line);
                    _ = try file.write("\n");
                }
            }
        }
    }

    _ = try file.write(LOG_FOOTER);
}
